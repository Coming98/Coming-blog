---
title: 02-TS的类型声明与基本操作
mathjax: false
date: 2022-07-04 21:59:44
summary: TS的类型声明与基本操作
categories: TypeScript
tags:
  - typescript-basic
---

# 显式类型

使用 `:` + `类型` 为目标变量制定显示类型

此外, TS 还能支持类型推断, 因此不用一直手动指定类型

# 常用类型

- 基本类型：`string`, `number`, `boolean`

```ts
let str: string = 'hello typescript'
let num: number = 100
let bool: boolean = true
```

- 数组: `type[]` 或 `Array<type>`

```ts
let arr: number[] = [1, 2, 3]
let strArr: string[] = ['1', '2', '3']

console.log(arr)
console.log(strArr)
```

- any 类型: 相当于关闭了相关的类型检查

- 函数类型

```ts
function greet(name: string): void {
    console.log("Hello, " + name)
}
```

- 对象类型:

```ts
// 逗号与分号都能当作分隔符
function printCoord(pt: { x: number, y: number }): void {
    console.log("坐标的 x 值为: " + pt.x)
    console.log("坐标的 y 值为: " + pt.y)
}
// ? 表示可选属性
function printName(obj: { first: string; last?: string }) {
    if(obj.last === undefined) {
        obj.last = ''
    } else {
        obj.last += ' '
    }
    console.log(obj.last + obj.first)
}
```

# 函数类型

故名思意, 其值是一个函数, 可以进一步规定其函数返回值的类型等

```ts
type Fish = { swim: () => void }
type Bird = { fly: () => void }
type Human = { swim?: () => void; fly?: () => void }

function move(animal: Fish | Bird | Human) {
    if ("swim" in animal) {
        // Fish | Human 但是 Human 可能没有 swim
        // 因此可以用断言进行空间缩小
        return (animal as Fish).swim()
    }
    // 可能是 Bird 或 Human 但是 Human 可能没有 fly
    return (animal as Bird).fly()
}

const petA: Fish = { swim: () => {
    console.log("petA is a Fish.")
}}
const petB: Bird = { fly: () => {
    console.log("petB is a Bird.")
}}
const petC: Human = {}

move(petA)
move(petB)
// move(petC) // 因为断言而报错
```

# 联合类型

表示可能是目标类型集中的任意一种类型

```ts
function printId(id: number | string) {
    if(typeof id === 'string'){
        console.log(id.toUpperCase())
    } else {
        console.log(id)
    }
}
```

因为传入的值可能是众多类型的一种, 因此需要进行类型判断:
- 判断是否为基本类型: `typeof value === 'string'` OR `number` OR `boolean`
- 判断是否为数组: `Array.isArray(value)`

# 文字类型

let 与 const: 文字类型就是去模拟 const 的声明限制

```ts
let testString = "hello world"
testString = "world hello"

const constantString = "hello world"
// constantString = "world hello" // Wrong

let x: 'hello' = 'hello' // 类型定义为 'hello' 其值只能是字符串 'hello'
let b1: true = true // 布尔文字类型
```

单独的应用其实就是 const, 但是结合联合类型, 就可以规定变量的内容选择空间

```ts
// demo-1
function printText(s: string, alignment: 'left' | 'right' | 'center') {
    console.log(alignment + ' : ' + s)
}
// demo-2
function compare(a: number, b: number): -1 | 0 | 1 {
    return a === b ? 0 : a > b ? 1 : -1;
}
```

## 与类型推断结合使用

当我们定义一个对象的属性但没有显示指明其类型时，ts 会自动帮助我们进行类型推断：

```ts
const obj2 = {
    count: 0 // 推断为 number 类型
}
if (true) {
    obj2.count = 1
    // obj2.count = "1" // Wrong:  Type 'string' is not assignable to type 'number'.
}
```

针对复杂的函数调用，我们可以将有限的可传递的参数封装为对象实现复用：

```ts
function handleRequest(url: string, method: 'GET' | 'POST' | 'GUESS') {
    // pass
}
const req = {
    url: 'https://example.com',
    method: 'GET',
}
// handleRequest(req.url, req.method) // Wrong: Argument of type 'string' is not assignable to parameter of type '"GET" | "POST" | "GUESS"'
```

但是基于类型推断，属性 method 会被推断为 string 类型，并不是函数参数所要求的文字类型，因此需要进行类型转换

```ts
// 比较简单的解决方案就是在参数对象定义时手动进行类型推断
const req = {
    url: 'https://example.com',
    method: 'GET' as 'GET'
}

// 或者直接将参数对象推断为文字类型
const req = {
    url: 'https://example.com',
    method: 'GET'
} as const
```


# null 和 undefined 类型

分别对应 JS 的 null 和 undefined 类型

声明与定义时会自动进行类型推断：
```ts
let x_11 = undefined // 自动推断 undefined
let x_11_1: undefined = undefined
let y_11 = null
let y_11_1: null = null
```

但是默认情况下（严格模式）其它类型的显示声明不能被赋值为 null 或 undefined：
```ts
// let z_11: string = undefined // 因为开启了 strictNullChecks 因此不能将 string 类型预定义为 undefined 类型
let z_11_1: string = undefined // 关闭后即可, 但是不建议关闭
```

针对 null 与 undefined 这两个类型，`!` 表示断言目标变量不为 null 或 undefined：
```js
function liveDangerously_11(x?: number | null) {
    // x! 表示断言(assert) 虽然支持 null 的输入，但是执行到这句时会进行异常处理
    console.log(x!.toFixed()) // 但是不推荐使用，复杂度提升可能导致潜在问题
}
liveDangerously_11(1.1)
// liveDangerously_11(null)
```

# type 类型别名

大型项目中可以将常用的类型集合预定义为某个类型别名(通常首字母大写)

```ts
type Point = {
    x: Number;
    y: number;
}
type ID = number | string

function printCoord2(pt: Point, id?: ID) {
    console.log(`X: ${pt.x}; Y: ${pt.y}`)
}
```

也支持扩展, 使用符号 `&` 实现继承的意思

```ts
type Animal = {
    name: string
}

type Bear = Animal & {
    honey: number
}
```

# 接口

将类型封装为结构, 更加工程化

```ts
interface Point3 {
    x: number,
    y: number,
}

function printCoord3(pt: Point) {
    console.log(`X: ${pt.x}; Y: ${pt.y}`)
}
```

并且支持多种类型的继承, 更适合完整优雅的工程

```ts
interface Animal {
    name: string
}

interface Bear extends Animal {
    honey: number
}

const teedyBear: Bear = {
    name: 'Teedy',
    honey: 100
}
```

## 添加新的字段

同名的接口不会覆盖, 而是会合并
> type 不支持重复定义进行类型合并

```ts
interface JCWindow {
    count: number
}

interface JCWindow {
    title: string
}

const myWindow: JCWindow = {
    count: 1,
    title: "JCWindow"
}
```

# 类型断言

类型断言: 针对内置的 JS 语法获取对象时, 指定对象的类型:

```ts
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement // Method 1
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas") // Method 2
```
# 枚举

TypeScript 为 JS 额外提供的语法, 

```ts
// Definition
enum Direction {
    Up = 1,
    Down, // default 2 - 枚举会自动提升
    Left,
    Right
}

// Assess
console.log(Direction.Up)
```

与 JS 代码对比一下：

```js
// Definition
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 1] = "Up";
    Direction[Direction["Down"] = 2] = "Down";
    Direction[Direction["Left"] = 3] = "Left";
    Direction[Direction["Right"] = 4] = "Right";
})(Direction || (Direction = {}));
// Assess
console.log(Direction.Up);
```

# 原语

不常用, 了解即可
- `bigint`: 表示非常大的整数, 对应 ES2020 以后引入的 `BigInt`
- `symbol`: 用于定义全局唯一的引用

```ts
const oneHundred: bigint = BigInt(100)
const anotherHundred: bigint = 100n

// 虽然都是符号 name, 但是他们的值是完全不一样的
const firstName = Symbol("name")
const lastName = Symbol("name")

// 始终返回 false
if (firstName === lastName) {
    console.log("Equal")
}
```
